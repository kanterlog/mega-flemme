"""
ü§ñ Agent Sylvie - C≈ìur de l'intelligence conversationnelle
Phase 3.9 - Agent principal avec IA hybride + Google Workspace complet

Sylvie : Votre assistante IA hybride (GPT + Gemini) pour KanterMator
avec acc√®s complet √† Gmail, Calendar, Drive et Sheets
"""

import uuidimport jsonimport refrom datetime import datetime, timedeltafrom typing import Dict, List, Optional, Tuple, Anyimport structlogimport asynciofrom app.services.sylvie_config import (    SylvieConfig, ConversationMessage, SylvieIntent,     SylvieResponse, SylvieCapability, ConversationRole)from app.services.hybrid_ai import hybrid_ai, TaskTypefrom app.services.sheets_reader import SheetsReaderfrom app.services.drive_manager import DriveManagerfrom app.services.scheduler import AutomationSchedulerfrom app.services.gmail_service import gmail_servicefrom app.services.calendar_service import calendar_servicefrom app.utils.config import settingsfrom app.utils.database import db_managerlogger = structlog.get_logger(__name__)class SylvieAgent:    """Agent conversationnel intelligent Sylvie avec IA hybride et Google Workspace"""        def __init__(self):        # Plus de client OpenAI direct - utilisation du service hybride        self.conversations: Dict[str, List[ConversationMessage]] = {}        self.sheets_reader = SheetsReader()        self.drive_manager = DriveManager()        self.scheduler = AutomationScheduler()        self.gmail_service = gmail_service        self.calendar_service = calendar_service                # Initialisation de Sylvie avec IA hybride        logger.info("ü§ñ Sylvie Agent hybride + Google Workspace initialis√©",                    ai_strategy=settings.AI_MODEL_STRATEGY,                   primary_model=settings.PRIMARY_MODEL)        async def process_message(self, message: str, conversation_id: str = None) -> SylvieResponse:        """        Traitement principal d'un message utilisateur                Args:            message: Message de l'utilisateur            conversation_id: ID de conversation (optionnel)                    Returns:            SylvieResponse avec la r√©ponse et m√©tadonn√©es        """        if not conversation_id:            conversation_id = str(uuid.uuid4())                # Ajout du message utilisateur √† l'historique        self._add_to_conversation(conversation_id, ConversationRole.USER, message)                logger.info("üí¨ Message utilisateur re√ßu",                    message=message[:100],                    conversation_id=conversation_id)                try:            # 1. Analyse de l'intention            intent = await self._analyze_intent(message, conversation_id)                        # 2. Ex√©cution de l'action si n√©cessaire            action_taken = None            action_result = None                        if intent and intent.action_required:                action_taken, action_result = await self._execute_action(intent)                        # 3. G√©n√©ration de la r√©ponse            response_message = await self._generate_response(                message, intent, action_taken, action_result, conversation_id            )                        # 4. G√©n√©ration de suggestions            suggestions = await self._generate_suggestions(intent, action_result)                        # Ajout de la r√©ponse √† l'historique            self._add_to_conversation(conversation_id, ConversationRole.ASSISTANT, response_message)                        # Construction de la r√©ponse finale            response = SylvieResponse(                message=response_message,                intent=intent,                action_taken=action_taken,                action_result=action_result,                suggestions=suggestions,                conversation_id=conversation_id            )                        logger.info("‚úÖ R√©ponse Sylvie g√©n√©r√©e",                        intent=intent.intent if intent else "non d√©tect√©e",                       action_taken=bool(action_taken))                        return response                    except Exception as e:            logger.error("‚ùå Erreur traitement message", error=str(e))            error_response = SylvieResponse(                message=f"üö® D√©sol√©e, j'ai rencontr√© une erreur : {str(e)}",                conversation_id=conversation_id            )            return error_response        async def _analyze_intent(self, message: str, conversation_id: str) -> Optional[SylvieIntent]:        """Analyse de l'intention de l'utilisateur avec IA hybride"""                try:            # Contexte de conversation pour l'analyse            conversation_context = self._get_conversation_context(conversation_id, last_n=3)                        intent_prompt = f"""            Analyse ce message utilisateur pour KanterMator et retourne un JSON avec l'intention d√©tect√©e.                        Message : "{message}"            Contexte : {conversation_context}                        Format JSON requis :            {{                "intent": "nom_intention",                "confidence": 0.95,                "capability": "une_des_capacit√©s",                "action_required": true/false,                "entities": {{}},                "parameters": {{}}            }}                        Capacit√©s disponibles (capability) :            - automation_control : start_automation, stop_automation, automation_status            - monitoring : system_health, check_logs, performance_metrics            - sheets_analysis : read_sheets, analyze_data, generate_report            - drive_management : list_files, organize_files, share_document            - email_management : check_emails, search_emails, send_email            - calendar_management : check_schedule, upcoming_events, create_event, check_conflicts            - system_health, check_integrations, view_logs            - help_request, explain_feature, show_capabilities            - resolve_error, reconnect_google, fix_permissions            """                        # Utilisation du service IA hybride pour l'analyse d'intention            ai_response = await hybrid_ai.generate_response(                prompt=intent_prompt,                task_type=TaskType.INTENT_ANALYSIS,                max_tokens=300,                temperature=0.3  # Plus d√©terministe pour l'analyse            )                        # Parsing de la r√©ponse JSON            try:                intent_data = json.loads(ai_response.content)                                return SylvieIntent(                    intent=intent_data["intent"],                    confidence=intent_data["confidence"],                    entities=intent_data.get("entities", {}),                    capability=SylvieCapability(intent_data["capability"]),                    action_required=intent_data.get("action_required", False),                    parameters=intent_data.get("parameters", {})                )                            except json.JSONDecodeError:                logger.warning("‚ö†Ô∏è R√©ponse IA non parsable comme JSON", response=ai_response.content)                return None                        except Exception as e:            logger.error("‚ùå Erreur lors de l'analyse d'intention", error=str(e))            return None        async def _execute_action(self, intent: SylvieIntent) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:        """Ex√©cution de l'action demand√©e par l'utilisateur"""        try:            action_result = None            action_taken = None                        logger.info("üéØ Ex√©cution d'action Sylvie",                        intent=intent.intent,                       capability=intent.capability)                        # Actions selon la capacit√©            if intent.capability == SylvieCapability.AUTOMATION_CONTROL:                action_taken, action_result = await self._handle_automation_control(intent)                            elif intent.capability == SylvieCapability.MONITORING:                action_taken, action_result = await self._handle_monitoring(intent)                            elif intent.capability == SylvieCapability.SHEETS_ANALYSIS:                action_taken, action_result = await self._handle_sheets_analysis(intent)                            elif intent.capability == SylvieCapability.DRIVE_MANAGEMENT:                action_taken, action_result = await self._handle_drive_management(intent)                            elif intent.capability == SylvieCapability.EMAIL_MANAGEMENT:                action_taken, action_result = await self._handle_email_management(intent)                            elif intent.capability == SylvieCapability.CALENDAR_MANAGEMENT:                action_taken, action_result = await self._handle_calendar_management(intent)                            elif intent.capability == SylvieCapability.SYSTEM_STATUS:                action_taken, action_result = await self._handle_system_status(intent)                            elif intent.capability == SylvieCapability.HELP_GUIDANCE:                action_taken, action_result = await self._handle_help_guidance(intent)                            elif intent.capability == SylvieCapability.ERROR_RESOLUTION:                action_taken, action_result = await self._handle_error_resolution(intent)                        return action_taken, action_result                    except Exception as e:            logger.error("‚ùå Erreur lors de l'ex√©cution d'action",                         intent=intent.intent if intent else "unknown",                        error=str(e))            return f"Erreur: {str(e)}", {"error": str(e)}        async def _handle_automation_control(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes d'automatisation"""                if intent.intent == "automation_status":            # V√©rification de l'√©tat de l'automatisation            with db_manager.get_session() as session:                from app.models import AutomationTask                                pending_tasks = session.query(AutomationTask).filter(                    AutomationTask.status == 'pending'                ).count()                                running_tasks = session.query(AutomationTask).filter(                    AutomationTask.status == 'running'                  ).count()                                last_completed = session.query(AutomationTask).filter(                    AutomationTask.status == 'completed'                ).order_by(AutomationTask.completed_at.desc()).first()                                return "V√©rification √©tat automatisation", {                    "pending_tasks": pending_tasks,                    "running_tasks": running_tasks,                    "last_completed": last_completed.completed_at.isoformat() if last_completed else None,                    "automation_enabled": settings.AUTOMATION_ENABLED                }                elif intent.intent == "start_automation":            # D√©marrage de l'automatisation            result = await self.scheduler.start_monitoring()            return "D√©marrage automatisation", {"started": result}                elif intent.intent == "stop_automation":            # Arr√™t de l'automatisation              result = await self.scheduler.stop_monitoring()            return "Arr√™t automatisation", {"stopped": result}                return "Action automatisation non reconnue", {"error": "Action non support√©e"}        async def _handle_monitoring(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du monitoring syst√®me"""                if intent.intent == "system_health":            # V√©rification sant√© syst√®me            health_status = {                "database": "Connect√©",                "redis": "Actif",                 "google_apis": "Autoris√©",                "ai_service": "Hybride GPT+Gemini"            }            return "V√©rification sant√© syst√®me", health_status                return "Action monitoring non reconnue", {"error": "Action non support√©e"}        async def _handle_sheets_analysis(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de l'analyse des feuilles"""                if intent.intent == "read_sheets":            # Lecture des feuilles r√©centes            try:                sheets = await self.sheets_reader.get_recent_sheets()                return "Lecture feuilles r√©centes", {"sheets": sheets}            except Exception as e:                return f"Erreur lecture feuilles: {str(e)}", {"error": str(e)}                return "Action sheets non reconnue", {"error": "Action non support√©e"}        async def _handle_drive_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du Drive"""                if intent.intent == "list_files":            # Liste des fichiers Drive            try:                files = await self.drive_manager.list_files(max_results=20)                return "Liste fichiers Drive", {"files": files}            except Exception as e:                return f"Erreur liste fichiers: {str(e)}", {"error": str(e)}                return "Action Drive non reconnue", {"error": "Action non support√©e"}        async def _handle_system_status(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du statut syst√®me"""                if intent.intent == "system_health":            status = {                "timestamp": datetime.utcnow().isoformat(),                "services": {                    "sylvie_agent": "‚úÖ Actif",                    "hybrid_ai": "‚úÖ GPT+Gemini",                    "google_workspace": "‚úÖ Gmail+Calendar+Drive+Sheets",                    "database": "‚úÖ PostgreSQL",                    "cache": "‚úÖ Redis",                    "automation": "‚úÖ Celery"                }            }            return "V√©rification statut global", status                return "Action statut non reconnue", {"error": "Action non support√©e"}        async def _handle_help_guidance(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de l'aide et guidance"""                if intent.intent == "show_capabilities":            capabilities = {                "automation": "Contr√¥le des automatisations √©ducatives",                "sheets": "Analyse feuilles Google Sheets",                "drive": "Gestion fichiers Google Drive",                 "email": "üìß Gestion Gmail (nouveau!)",                "calendar": "üìÖ Gestion Calendar (nouveau!)",                "monitoring": "Surveillance syst√®me",                "help": "Assistance et guidance"            }            return "Affichage des capacit√©s", {"capabilities": capabilities}                return "Action aide non reconnue", {"error": "Action non support√©e"}        async def _handle_error_resolution(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de la r√©solution d'erreurs"""                if intent.intent == "reconnect_google":            try:                # Test de reconnexion Google                test_result = await self.gmail_service.get_email_summary_for_sylvie()                return "Test connexion Google", {"status": "Connect√©", "test": "Gmail OK"}            except Exception as e:                return f"Erreur connexion Google: {str(e)}", {"error": str(e)}                return "Action r√©solution non reconnue", {"error": "Action non support√©e"}        async def _handle_email_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes email"""                if intent.intent == "check_emails":            # V√©rification des nouveaux emails            try:                unread_emails = await self.gmail_service.get_unread_emails(max_results=10)                summary = await self.gmail_service.get_email_summary_for_sylvie()                                return "V√©rification des emails", {                    "unread_count": len(unread_emails),                    "unread_emails": unread_emails,                    "summary": summary                }            except Exception as e:                return f"Erreur v√©rification emails: {str(e)}", {"error": str(e)}                elif intent.intent == "search_emails":            # Recherche d'emails            query = intent.parameters.get("query", "")            max_results = intent.parameters.get("max_results", 10)                        try:                search_results = await self.gmail_service.search_emails(query, max_results)                return f"Recherche emails: '{query}'", {                    "query": query,                    "results": search_results,                    "count": len(search_results)                }            except Exception as e:                return f"Erreur recherche emails: {str(e)}", {"error": str(e)}                elif intent.intent == "send_email":            # Envoi d'email            to = intent.parameters.get("to", "")            subject = intent.parameters.get("subject", "")            body = intent.parameters.get("body", "")                        if not all([to, subject, body]):                return "Param√®tres manquants pour l'envoi", {                    "error": "to, subject et body requis"                }                        try:                success = await self.gmail_service.send_email(to, subject, body)                if success:                    return f"Email envoy√© √† {to}", {"to": to, "subject": subject}                else:                    return f"√âchec envoi email √† {to}", {"error": "Envoi √©chou√©"}            except Exception as e:                return f"Erreur envoi email: {str(e)}", {"error": str(e)}                return "Action email non reconnue", {"error": "Action non support√©e"}        async def _handle_calendar_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes calendrier"""                if intent.intent == "check_schedule":            # V√©rification du planning            try:                today_schedule = await self.calendar_service.get_today_schedule()                summary = await self.calendar_service.get_calendar_summary_for_sylvie()                                return "V√©rification du planning", {                    "today": today_schedule,                    "summary": summary                }            except Exception as e:                return f"Erreur v√©rification planning: {str(e)}", {"error": str(e)}                elif intent.intent == "upcoming_events":            # √âv√©nements √† venir            days_ahead = intent.parameters.get("days", 7)            max_results = intent.parameters.get("max_results", 10)                        try:                upcoming = await self.calendar_service.get_upcoming_events(                    max_results=max_results,                    days_ahead=days_ahead                )                return f"√âv√©nements {days_ahead} prochains jours", {                    "events": upcoming,                    "count": len(upcoming),                    "days_ahead": days_ahead                }            except Exception as e:                return f"Erreur √©v√©nements √† venir: {str(e)}", {"error": str(e)}                elif intent.intent == "check_conflicts":            # V√©rification des conflits            try:                conflicts = await self.calendar_service.check_scheduling_conflicts()                return "V√©rification conflits planning", {                    "conflicts": conflicts,                    "count": len(conflicts),                    "has_conflicts": len(conflicts) > 0                }            except Exception as e:                return f"Erreur v√©rification conflits: {str(e)}", {"error": str(e)}                elif intent.intent == "create_event":            # Cr√©ation d'√©v√©nement            summary = intent.parameters.get("summary", "")            start_time_str = intent.parameters.get("start_time", "")            duration_hours = intent.parameters.get("duration_hours", 1)                        if not all([summary, start_time_str]):                return "Param√®tres manquants pour cr√©ation √©v√©nement", {                    "error": "summary et start_time requis"                }                        try:                from datetime import datetime, timedelta                start_time = datetime.fromisoformat(start_time_str)                end_time = start_time + timedelta(hours=duration_hours)                                success = await self.calendar_service.create_event(                    summary=summary,                    start_time=start_time,                    end_time=end_time,                    description=intent.parameters.get("description", ""),                    location=intent.parameters.get("location", "")                )                                if success:                    return f"√âv√©nement cr√©√©: {summary}", {                        "summary": summary,                        "start_time": start_time_str,                        "duration_hours": duration_hours                    }                else:                    return f"√âchec cr√©ation √©v√©nement: {summary}", {"error": "Cr√©ation √©chou√©e"}            except Exception as e:                return f"Erreur cr√©ation √©v√©nement: {str(e)}", {"error": str(e)}                return "Action calendrier non reconnue", {"error": "Action non support√©e"}        async def _generate_response(self, user_message: str,                                intent: Optional[SylvieIntent],                               action_taken: Optional[str],                               action_result: Optional[Dict[str, Any]],                               conversation_id: str) -> str:        """G√©n√©ration de la r√©ponse conversationnelle de Sylvie"""                response_prompt = f"""        Tu es Sylvie, l'assistante IA hybride de KanterMator. G√©n√®re une r√©ponse naturelle et amicale.                Message utilisateur : "{user_message}"                Contexte :        - Intention d√©tect√©e : {intent.intent if intent else "Non d√©tect√©e"}        - Action effectu√©e : {action_taken}        - R√©sultat : {json.dumps(action_result, default=str) if action_result else "Aucun"}                R√®gles pour ta r√©ponse :        1. Utilise des emojis appropri√©s        2. Sois concise mais informative          3. Explique clairement ce qui a √©t√© fait        4. Propose une aide suppl√©mentaire si pertinent        5. Reste dans le contexte √©ducatif        6. Maximum 200 mots                G√©n√®re uniquement ta r√©ponse directe, sans pr√©ambule.        """                try:            # Utilisation du service IA hybride            ai_response = await hybrid_ai.generate_response(                prompt=response_prompt,                task_type=TaskType.CONVERSATION,                max_tokens=400,                temperature=0.7,                system_prompt=SylvieConfig.SYSTEM_PROMPT            )                        return ai_response.content.strip()        except:            # R√©ponse de fallback            if action_taken:                return f"‚úÖ J'ai effectu√© l'action : {action_taken}. Comment puis-je vous aider davantage ?"            else:                return "üòä Je suis l√† pour vous aider avec KanterMator ! Que souhaitez-vous faire ?"        async def _generate_suggestions(self, intent: Optional[SylvieIntent],                                   action_result: Optional[Dict[str, Any]]) -> List[str]:        """G√©n√©ration de suggestions contextuelles"""                suggestions = []                if intent:            if intent.capability == SylvieCapability.EMAIL_MANAGEMENT:                suggestions = [                    "üìß V√©rifier les emails urgents",                    "üîç Rechercher un email sp√©cifique",                     "üì§ Envoyer un email automatis√©"                ]            elif intent.capability == SylvieCapability.CALENDAR_MANAGEMENT:                suggestions = [                    "üìÖ Voir le planning du jour",                    "‚è∞ V√©rifier les conflits d'horaires",                    "‚ûï Cr√©er un nouvel √©v√©nement"                ]            elif intent.capability == SylvieCapability.AUTOMATION_CONTROL:                suggestions = [                    "üîÑ V√©rifier l'√©tat des automatisations",                    "üìä Voir les t√¢ches en cours",                    "‚öôÔ∏è G√©rer les param√®tres"                ]            else:                suggestions = [                    "üìö Analyser une feuille Google Sheets",                    "üìÅ Organiser les fichiers Drive",                    "üîç V√©rifier le statut syst√®me"                ]        else:            suggestions = [                "üí° Afficher mes capacit√©s",                "üìß V√©rifier mes emails",                "üìÖ Consulter mon planning",                "üîÑ √âtat des automatisations"            ]                return suggestions[:3]  # Maximum 3 suggestions        def _add_to_conversation(self, conversation_id: str, role: ConversationRole, content: str):        """Ajout d'un message √† l'historique de conversation"""                if conversation_id not in self.conversations:            self.conversations[conversation_id] = []                message = ConversationMessage(role=role, content=content)        self.conversations[conversation_id].append(message)                # Limitation de la taille de l'historique        if len(self.conversations[conversation_id]) > SylvieConfig.MAX_CONVERSATION_LENGTH:            self.conversations[conversation_id] = self.conversations[conversation_id][-SylvieConfig.MAX_CONVERSATION_LENGTH:]        def _get_conversation_context(self, conversation_id: str, last_n: int = 5) -> str:        """R√©cup√©ration du contexte de conversation"""                if conversation_id not in self.conversations:            return "Nouvelle conversation"                recent_messages = self.conversations[conversation_id][-last_n:]        context_parts = []                for msg in recent_messages:            role_emoji = "üë§" if msg.role == ConversationRole.USER else "ü§ñ"            context_parts.append(f"{role_emoji} {msg.content[:100]}")                return " | ".join(context_parts)        def get_conversation_history(self, conversation_id: str) -> List[ConversationMessage]:        """R√©cup√©ration de l'historique complet d'une conversation"""        return self.conversations.get(conversation_id, [])        def clear_conversation(self, conversation_id: str):        """Nettoyage d'une conversation"""        if conversation_id in self.conversations:            del self.conversations[conversation_id]            logger.info("üßπ Conversation supprim√©e", conversation_id=conversation_id)# Instance globale de l'agent Sylviesylvie = SylvieAgent()