"""
🤖 Agent Sylvie - Cœur de l'intelligence conversationnelle
Phase 3.9 - Agent principal avec IA hybride + Google Workspace complet

Sylvie : Votre assistante IA hybride (GPT + Gemini) pour KanterMator
avec accès complet à Gmail, Calendar, Drive et Sheets
"""

import uuidimport jsonimport refrom datetime import datetime, timedeltafrom typing import Dict, List, Optional, Tuple, Anyimport structlogimport asynciofrom app.services.sylvie_config import (    SylvieConfig, ConversationMessage, SylvieIntent,     SylvieResponse, SylvieCapability, ConversationRole)from app.services.hybrid_ai import hybrid_ai, TaskTypefrom app.services.sheets_reader import SheetsReaderfrom app.services.drive_manager import DriveManagerfrom app.services.scheduler import AutomationSchedulerfrom app.services.gmail_service import gmail_servicefrom app.services.calendar_service import calendar_servicefrom app.utils.config import settingsfrom app.utils.database import db_managerlogger = structlog.get_logger(__name__)class SylvieAgent:    """Agent conversationnel intelligent Sylvie avec IA hybride et Google Workspace"""        def __init__(self):        # Plus de client OpenAI direct - utilisation du service hybride        self.conversations: Dict[str, List[ConversationMessage]] = {}        self.sheets_reader = SheetsReader()        self.drive_manager = DriveManager()        self.scheduler = AutomationScheduler()        self.gmail_service = gmail_service        self.calendar_service = calendar_service                # Initialisation de Sylvie avec IA hybride        logger.info("🤖 Sylvie Agent hybride + Google Workspace initialisé",                    ai_strategy=settings.AI_MODEL_STRATEGY,                   primary_model=settings.PRIMARY_MODEL)        async def process_message(self, message: str, conversation_id: str = None) -> SylvieResponse:        """        Traitement principal d'un message utilisateur                Args:            message: Message de l'utilisateur            conversation_id: ID de conversation (optionnel)                    Returns:            SylvieResponse avec la réponse et métadonnées        """        if not conversation_id:            conversation_id = str(uuid.uuid4())                # Ajout du message utilisateur à l'historique        self._add_to_conversation(conversation_id, ConversationRole.USER, message)                logger.info("💬 Message utilisateur reçu",                    message=message[:100],                    conversation_id=conversation_id)                try:            # 1. Analyse de l'intention            intent = await self._analyze_intent(message, conversation_id)                        # 2. Exécution de l'action si nécessaire            action_taken = None            action_result = None                        if intent and intent.action_required:                action_taken, action_result = await self._execute_action(intent)                        # 3. Génération de la réponse            response_message = await self._generate_response(                message, intent, action_taken, action_result, conversation_id            )                        # 4. Génération de suggestions            suggestions = await self._generate_suggestions(intent, action_result)                        # Ajout de la réponse à l'historique            self._add_to_conversation(conversation_id, ConversationRole.ASSISTANT, response_message)                        # Construction de la réponse finale            response = SylvieResponse(                message=response_message,                intent=intent,                action_taken=action_taken,                action_result=action_result,                suggestions=suggestions,                conversation_id=conversation_id            )                        logger.info("✅ Réponse Sylvie générée",                        intent=intent.intent if intent else "non détectée",                       action_taken=bool(action_taken))                        return response                    except Exception as e:            logger.error("❌ Erreur traitement message", error=str(e))            error_response = SylvieResponse(                message=f"🚨 Désolée, j'ai rencontré une erreur : {str(e)}",                conversation_id=conversation_id            )            return error_response        async def _analyze_intent(self, message: str, conversation_id: str) -> Optional[SylvieIntent]:        """Analyse de l'intention de l'utilisateur avec IA hybride"""                try:            # Contexte de conversation pour l'analyse            conversation_context = self._get_conversation_context(conversation_id, last_n=3)                        intent_prompt = f"""            Analyse ce message utilisateur pour KanterMator et retourne un JSON avec l'intention détectée.                        Message : "{message}"            Contexte : {conversation_context}                        Format JSON requis :            {{                "intent": "nom_intention",                "confidence": 0.95,                "capability": "une_des_capacités",                "action_required": true/false,                "entities": {{}},                "parameters": {{}}            }}                        Capacités disponibles (capability) :            - automation_control : start_automation, stop_automation, automation_status            - monitoring : system_health, check_logs, performance_metrics            - sheets_analysis : read_sheets, analyze_data, generate_report            - drive_management : list_files, organize_files, share_document            - email_management : check_emails, search_emails, send_email            - calendar_management : check_schedule, upcoming_events, create_event, check_conflicts            - system_health, check_integrations, view_logs            - help_request, explain_feature, show_capabilities            - resolve_error, reconnect_google, fix_permissions            """                        # Utilisation du service IA hybride pour l'analyse d'intention            ai_response = await hybrid_ai.generate_response(                prompt=intent_prompt,                task_type=TaskType.INTENT_ANALYSIS,                max_tokens=300,                temperature=0.3  # Plus déterministe pour l'analyse            )                        # Parsing de la réponse JSON            try:                intent_data = json.loads(ai_response.content)                                return SylvieIntent(                    intent=intent_data["intent"],                    confidence=intent_data["confidence"],                    entities=intent_data.get("entities", {}),                    capability=SylvieCapability(intent_data["capability"]),                    action_required=intent_data.get("action_required", False),                    parameters=intent_data.get("parameters", {})                )                            except json.JSONDecodeError:                logger.warning("⚠️ Réponse IA non parsable comme JSON", response=ai_response.content)                return None                        except Exception as e:            logger.error("❌ Erreur lors de l'analyse d'intention", error=str(e))            return None        async def _execute_action(self, intent: SylvieIntent) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:        """Exécution de l'action demandée par l'utilisateur"""        try:            action_result = None            action_taken = None                        logger.info("🎯 Exécution d'action Sylvie",                        intent=intent.intent,                       capability=intent.capability)                        # Actions selon la capacité            if intent.capability == SylvieCapability.AUTOMATION_CONTROL:                action_taken, action_result = await self._handle_automation_control(intent)                            elif intent.capability == SylvieCapability.MONITORING:                action_taken, action_result = await self._handle_monitoring(intent)                            elif intent.capability == SylvieCapability.SHEETS_ANALYSIS:                action_taken, action_result = await self._handle_sheets_analysis(intent)                            elif intent.capability == SylvieCapability.DRIVE_MANAGEMENT:                action_taken, action_result = await self._handle_drive_management(intent)                            elif intent.capability == SylvieCapability.EMAIL_MANAGEMENT:                action_taken, action_result = await self._handle_email_management(intent)                            elif intent.capability == SylvieCapability.CALENDAR_MANAGEMENT:                action_taken, action_result = await self._handle_calendar_management(intent)                            elif intent.capability == SylvieCapability.SYSTEM_STATUS:                action_taken, action_result = await self._handle_system_status(intent)                            elif intent.capability == SylvieCapability.HELP_GUIDANCE:                action_taken, action_result = await self._handle_help_guidance(intent)                            elif intent.capability == SylvieCapability.ERROR_RESOLUTION:                action_taken, action_result = await self._handle_error_resolution(intent)                        return action_taken, action_result                    except Exception as e:            logger.error("❌ Erreur lors de l'exécution d'action",                         intent=intent.intent if intent else "unknown",                        error=str(e))            return f"Erreur: {str(e)}", {"error": str(e)}        async def _handle_automation_control(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes d'automatisation"""                if intent.intent == "automation_status":            # Vérification de l'état de l'automatisation            with db_manager.get_session() as session:                from app.models import AutomationTask                                pending_tasks = session.query(AutomationTask).filter(                    AutomationTask.status == 'pending'                ).count()                                running_tasks = session.query(AutomationTask).filter(                    AutomationTask.status == 'running'                  ).count()                                last_completed = session.query(AutomationTask).filter(                    AutomationTask.status == 'completed'                ).order_by(AutomationTask.completed_at.desc()).first()                                return "Vérification état automatisation", {                    "pending_tasks": pending_tasks,                    "running_tasks": running_tasks,                    "last_completed": last_completed.completed_at.isoformat() if last_completed else None,                    "automation_enabled": settings.AUTOMATION_ENABLED                }                elif intent.intent == "start_automation":            # Démarrage de l'automatisation            result = await self.scheduler.start_monitoring()            return "Démarrage automatisation", {"started": result}                elif intent.intent == "stop_automation":            # Arrêt de l'automatisation              result = await self.scheduler.stop_monitoring()            return "Arrêt automatisation", {"stopped": result}                return "Action automatisation non reconnue", {"error": "Action non supportée"}        async def _handle_monitoring(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du monitoring système"""                if intent.intent == "system_health":            # Vérification santé système            health_status = {                "database": "Connecté",                "redis": "Actif",                 "google_apis": "Autorisé",                "ai_service": "Hybride GPT+Gemini"            }            return "Vérification santé système", health_status                return "Action monitoring non reconnue", {"error": "Action non supportée"}        async def _handle_sheets_analysis(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de l'analyse des feuilles"""                if intent.intent == "read_sheets":            # Lecture des feuilles récentes            try:                sheets = await self.sheets_reader.get_recent_sheets()                return "Lecture feuilles récentes", {"sheets": sheets}            except Exception as e:                return f"Erreur lecture feuilles: {str(e)}", {"error": str(e)}                return "Action sheets non reconnue", {"error": "Action non supportée"}        async def _handle_drive_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du Drive"""                if intent.intent == "list_files":            # Liste des fichiers Drive            try:                files = await self.drive_manager.list_files(max_results=20)                return "Liste fichiers Drive", {"files": files}            except Exception as e:                return f"Erreur liste fichiers: {str(e)}", {"error": str(e)}                return "Action Drive non reconnue", {"error": "Action non supportée"}        async def _handle_system_status(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion du statut système"""                if intent.intent == "system_health":            status = {                "timestamp": datetime.utcnow().isoformat(),                "services": {                    "sylvie_agent": "✅ Actif",                    "hybrid_ai": "✅ GPT+Gemini",                    "google_workspace": "✅ Gmail+Calendar+Drive+Sheets",                    "database": "✅ PostgreSQL",                    "cache": "✅ Redis",                    "automation": "✅ Celery"                }            }            return "Vérification statut global", status                return "Action statut non reconnue", {"error": "Action non supportée"}        async def _handle_help_guidance(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de l'aide et guidance"""                if intent.intent == "show_capabilities":            capabilities = {                "automation": "Contrôle des automatisations éducatives",                "sheets": "Analyse feuilles Google Sheets",                "drive": "Gestion fichiers Google Drive",                 "email": "📧 Gestion Gmail (nouveau!)",                "calendar": "📅 Gestion Calendar (nouveau!)",                "monitoring": "Surveillance système",                "help": "Assistance et guidance"            }            return "Affichage des capacités", {"capabilities": capabilities}                return "Action aide non reconnue", {"error": "Action non supportée"}        async def _handle_error_resolution(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion de la résolution d'erreurs"""                if intent.intent == "reconnect_google":            try:                # Test de reconnexion Google                test_result = await self.gmail_service.get_email_summary_for_sylvie()                return "Test connexion Google", {"status": "Connecté", "test": "Gmail OK"}            except Exception as e:                return f"Erreur connexion Google: {str(e)}", {"error": str(e)}                return "Action résolution non reconnue", {"error": "Action non supportée"}        async def _handle_email_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes email"""                if intent.intent == "check_emails":            # Vérification des nouveaux emails            try:                unread_emails = await self.gmail_service.get_unread_emails(max_results=10)                summary = await self.gmail_service.get_email_summary_for_sylvie()                                return "Vérification des emails", {                    "unread_count": len(unread_emails),                    "unread_emails": unread_emails,                    "summary": summary                }            except Exception as e:                return f"Erreur vérification emails: {str(e)}", {"error": str(e)}                elif intent.intent == "search_emails":            # Recherche d'emails            query = intent.parameters.get("query", "")            max_results = intent.parameters.get("max_results", 10)                        try:                search_results = await self.gmail_service.search_emails(query, max_results)                return f"Recherche emails: '{query}'", {                    "query": query,                    "results": search_results,                    "count": len(search_results)                }            except Exception as e:                return f"Erreur recherche emails: {str(e)}", {"error": str(e)}                elif intent.intent == "send_email":            # Envoi d'email            to = intent.parameters.get("to", "")            subject = intent.parameters.get("subject", "")            body = intent.parameters.get("body", "")                        if not all([to, subject, body]):                return "Paramètres manquants pour l'envoi", {                    "error": "to, subject et body requis"                }                        try:                success = await self.gmail_service.send_email(to, subject, body)                if success:                    return f"Email envoyé à {to}", {"to": to, "subject": subject}                else:                    return f"Échec envoi email à {to}", {"error": "Envoi échoué"}            except Exception as e:                return f"Erreur envoi email: {str(e)}", {"error": str(e)}                return "Action email non reconnue", {"error": "Action non supportée"}        async def _handle_calendar_management(self, intent: SylvieIntent) -> Tuple[str, Dict[str, Any]]:        """Gestion des commandes calendrier"""                if intent.intent == "check_schedule":            # Vérification du planning            try:                today_schedule = await self.calendar_service.get_today_schedule()                summary = await self.calendar_service.get_calendar_summary_for_sylvie()                                return "Vérification du planning", {                    "today": today_schedule,                    "summary": summary                }            except Exception as e:                return f"Erreur vérification planning: {str(e)}", {"error": str(e)}                elif intent.intent == "upcoming_events":            # Événements à venir            days_ahead = intent.parameters.get("days", 7)            max_results = intent.parameters.get("max_results", 10)                        try:                upcoming = await self.calendar_service.get_upcoming_events(                    max_results=max_results,                    days_ahead=days_ahead                )                return f"Événements {days_ahead} prochains jours", {                    "events": upcoming,                    "count": len(upcoming),                    "days_ahead": days_ahead                }            except Exception as e:                return f"Erreur événements à venir: {str(e)}", {"error": str(e)}                elif intent.intent == "check_conflicts":            # Vérification des conflits            try:                conflicts = await self.calendar_service.check_scheduling_conflicts()                return "Vérification conflits planning", {                    "conflicts": conflicts,                    "count": len(conflicts),                    "has_conflicts": len(conflicts) > 0                }            except Exception as e:                return f"Erreur vérification conflits: {str(e)}", {"error": str(e)}                elif intent.intent == "create_event":            # Création d'événement            summary = intent.parameters.get("summary", "")            start_time_str = intent.parameters.get("start_time", "")            duration_hours = intent.parameters.get("duration_hours", 1)                        if not all([summary, start_time_str]):                return "Paramètres manquants pour création événement", {                    "error": "summary et start_time requis"                }                        try:                from datetime import datetime, timedelta                start_time = datetime.fromisoformat(start_time_str)                end_time = start_time + timedelta(hours=duration_hours)                                success = await self.calendar_service.create_event(                    summary=summary,                    start_time=start_time,                    end_time=end_time,                    description=intent.parameters.get("description", ""),                    location=intent.parameters.get("location", "")                )                                if success:                    return f"Événement créé: {summary}", {                        "summary": summary,                        "start_time": start_time_str,                        "duration_hours": duration_hours                    }                else:                    return f"Échec création événement: {summary}", {"error": "Création échouée"}            except Exception as e:                return f"Erreur création événement: {str(e)}", {"error": str(e)}                return "Action calendrier non reconnue", {"error": "Action non supportée"}        async def _generate_response(self, user_message: str,                                intent: Optional[SylvieIntent],                               action_taken: Optional[str],                               action_result: Optional[Dict[str, Any]],                               conversation_id: str) -> str:        """Génération de la réponse conversationnelle de Sylvie"""                response_prompt = f"""        Tu es Sylvie, l'assistante IA hybride de KanterMator. Génère une réponse naturelle et amicale.                Message utilisateur : "{user_message}"                Contexte :        - Intention détectée : {intent.intent if intent else "Non détectée"}        - Action effectuée : {action_taken}        - Résultat : {json.dumps(action_result, default=str) if action_result else "Aucun"}                Règles pour ta réponse :        1. Utilise des emojis appropriés        2. Sois concise mais informative          3. Explique clairement ce qui a été fait        4. Propose une aide supplémentaire si pertinent        5. Reste dans le contexte éducatif        6. Maximum 200 mots                Génère uniquement ta réponse directe, sans préambule.        """                try:            # Utilisation du service IA hybride            ai_response = await hybrid_ai.generate_response(                prompt=response_prompt,                task_type=TaskType.CONVERSATION,                max_tokens=400,                temperature=0.7,                system_prompt=SylvieConfig.SYSTEM_PROMPT            )                        return ai_response.content.strip()        except:            # Réponse de fallback            if action_taken:                return f"✅ J'ai effectué l'action : {action_taken}. Comment puis-je vous aider davantage ?"            else:                return "😊 Je suis là pour vous aider avec KanterMator ! Que souhaitez-vous faire ?"        async def _generate_suggestions(self, intent: Optional[SylvieIntent],                                   action_result: Optional[Dict[str, Any]]) -> List[str]:        """Génération de suggestions contextuelles"""                suggestions = []                if intent:            if intent.capability == SylvieCapability.EMAIL_MANAGEMENT:                suggestions = [                    "📧 Vérifier les emails urgents",                    "🔍 Rechercher un email spécifique",                     "📤 Envoyer un email automatisé"                ]            elif intent.capability == SylvieCapability.CALENDAR_MANAGEMENT:                suggestions = [                    "📅 Voir le planning du jour",                    "⏰ Vérifier les conflits d'horaires",                    "➕ Créer un nouvel événement"                ]            elif intent.capability == SylvieCapability.AUTOMATION_CONTROL:                suggestions = [                    "🔄 Vérifier l'état des automatisations",                    "📊 Voir les tâches en cours",                    "⚙️ Gérer les paramètres"                ]            else:                suggestions = [                    "📚 Analyser une feuille Google Sheets",                    "📁 Organiser les fichiers Drive",                    "🔍 Vérifier le statut système"                ]        else:            suggestions = [                "💡 Afficher mes capacités",                "📧 Vérifier mes emails",                "📅 Consulter mon planning",                "🔄 État des automatisations"            ]                return suggestions[:3]  # Maximum 3 suggestions        def _add_to_conversation(self, conversation_id: str, role: ConversationRole, content: str):        """Ajout d'un message à l'historique de conversation"""                if conversation_id not in self.conversations:            self.conversations[conversation_id] = []                message = ConversationMessage(role=role, content=content)        self.conversations[conversation_id].append(message)                # Limitation de la taille de l'historique        if len(self.conversations[conversation_id]) > SylvieConfig.MAX_CONVERSATION_LENGTH:            self.conversations[conversation_id] = self.conversations[conversation_id][-SylvieConfig.MAX_CONVERSATION_LENGTH:]        def _get_conversation_context(self, conversation_id: str, last_n: int = 5) -> str:        """Récupération du contexte de conversation"""                if conversation_id not in self.conversations:            return "Nouvelle conversation"                recent_messages = self.conversations[conversation_id][-last_n:]        context_parts = []                for msg in recent_messages:            role_emoji = "👤" if msg.role == ConversationRole.USER else "🤖"            context_parts.append(f"{role_emoji} {msg.content[:100]}")                return " | ".join(context_parts)        def get_conversation_history(self, conversation_id: str) -> List[ConversationMessage]:        """Récupération de l'historique complet d'une conversation"""        return self.conversations.get(conversation_id, [])        def clear_conversation(self, conversation_id: str):        """Nettoyage d'une conversation"""        if conversation_id in self.conversations:            del self.conversations[conversation_id]            logger.info("🧹 Conversation supprimée", conversation_id=conversation_id)# Instance globale de l'agent Sylviesylvie = SylvieAgent()